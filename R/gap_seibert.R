
#' Combine two values of a parameter type using weighted probabilities
#'
#' @param param A 'param' object
#' @param value1 The first value
#' @param value2 The second value
#' @param prob A named \code{list} in the form \code{functionname=probability}.
#'   The function described by \code{functionname} should take the parameter as
#'   its first argument and (at least) two vector parameters of arbitrary length
#'   and return a vector of identical length. Examples include
#'   \link{breed.use1}, \link{breed.use2}, \link{breed.rinterpolate}, and
#'   \link{breed.mutate}.
#' @param seed A random number seed for replicability.
#' @param cols A combination of 'result', 'func', 'value1', and/or 'value2'. Passing multiple column
#'   names will result in a data.frame; passing a single column will result in a vector. This
#'   is helpful for debugging.
#' @param validate TRUE to validate arguments, FALSE otherwise. In most cases this function gets
#'   called hundreds to thousands of times using values that were generated by the function
#'   itself. Using validation may help track down bugs when unexpected output occurs.
#'
#' @return A vector of new parameter values, or a data.frame if multiple \code{cols} are
#'   passed.
#' @export
#'
#' @references
#' Seibert, J. 2000. Multi-criteria calibration of a conceptual runoff model using a
#' generic algorithm. Hydrology and Earth System Sciences 4(2): 215â€“224.
#'
#' @examples
#' p <- param.discrete(c('heads', 'tails', 'edge of coin'), weights=c(0.45, 0.45, 0.1))
#' v1 <- random.value(p, n=10)
#' v2 <- random.value(p, n=10)
#' seibert.breed(p, v1, v2, cols=c('value1', 'value2', 'func', 'result'))
#'
seibert.breed <- function(param, value1, value2,
                          prob=list(breed.use1=0.41, breed.use2=0.41,
                                    breed.rinterpolate=0.16, breed.mutate=0.02),
                          seed=NULL, cols="result", validate=TRUE) {
  if(validate) {
    if(!is.param(param)) stop("Argument 'param' must be of type 'param'")
    # check columns
    if(length(cols) == 0) stop("Argument 'cols' must have length > 0")
    badcols <- cols[!(cols %in% c('value1', 'value2', 'func', 'result'))]
    if(length(badcols) > 0) stop("Invalid columns passed as 'cols': ", paste(badcols, collapse=", "))

    # check function names
    if(!is.list(prob)) stop("Argument 'prob' must be of type 'list'")
    if(length(prob) == 0) stop("Argument 'prob' must have length > 0")
    funs <- names(prob)
    if(is.null(funs) || any(nchar(funs) == 0)) stop("Argument 'prob' must be a named list")
    lapply(names(prob), match.fun)

    # check probabilities
    if(any(!is.finite(unlist(prob)))) stop("Function probabilities must be finite")

    # check for bad values
    badvals <- c(value1[!is.param.valid(param, value1)], value2[!is.param.valid(param, value2)])
    if(length(badvals) > 0) stop("Invalid values passed: ", paste0("'", badvals, "'", collapse=", "))
  }

  # if zero length values are passed
  if((length(value1) == 0) && (length(value2) == 0)) {
    if(length(cols) > 1) {
      # return emtpy data frame with requested columns
      return(data.frame(sapply(cols, function(col) NA, simplify=FALSE))[FALSE, ])
    } else {
      return(NULL)
    }
  }

  # making a data frame ensures identical length for value1 and value2
  df <- data.frame(value1=value1, value2=value2, stringsAsFactors = FALSE)

  # param args can override function probabilities
  prob <- sapply(names(prob), function(n) {
    if(!is.null(param[[n]])) {
      param[[n]]
    } else {
      prob[[n]]
    }
  })

  # seed for replicability (before anything random happens)
  if(!is.null(seed)) set.seed(seed)

  df$func <- names(prob)[sample(length(prob), size=nrow(df), prob=unlist(prob), replace=TRUE)]
  df$result <- NA
  # probably a more efficient way to do this
  for(fun in names(prob)) {
    filter <- df$func == fun
    if(sum(filter) == 0) next
    df$result[filter] <- do.call(fun, list(param, df$value1[filter], df$value2[filter]))
  }

  if(length(cols) > 1) {
    df[, cols, drop=FALSE]
  } else {
    df[[cols]]
  }
}

#' Parameter breeding functions
#'
#' @param param An object of type 'param'
#' @param value1 The first parameter value
#' @param value2 The second parameter value
#'
#' @return A vector of valid parameter values
#' @export
#'
#' @rdname breeding
breed.use1 <- function(param, value1, value2) value1

#' @rdname breeding
#' @export
breed.use2 <- function(param, value1, value2) value2

#' @rdname breeding
#' @export
breed.mutate <- function(param, value1, value2) random.value(param, n=length(value1))

#' @rdname breeding
#' @export
breed.rinterpolate <- function(param, value1, value2) UseMethod("breed.rinterpolate")

#' @rdname breeding
#' @export
breed.rinterpolate.param.real <- function(param, value1, value2) {
  runif(n=length(value1), 0, 1) * (value2 - value1) + value1
}

#' @rdname breeding
#' @export
breed.rinterpolate.param.discrete <- function(param, value1, value2) {
  if(param$ordered) {
    int1 <- match(value1, param$choices)
    int2 <- match(value2, param$choices)
    param$choices[round(breed.rinterpolate.param.real(NULL, int1, int2))]
  } else {
    c(value1, value2)[sample(2, size = length(value1), replace = TRUE)]
  }
}

#' @rdname breeding
#' @export
breed.rinterpolate.param.distributed <- function(param, value1, value2) {
  breed.rinterpolate.param.real(param, value1, value2)
}

#' @rdname breeding
#' @export
breed.rinterpolate.param.distr.int <- function(param, value1, value2) {
  round(breed.rinterpolate.param.real(param, value1, value2))
}


